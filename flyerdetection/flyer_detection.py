# -*- coding: utf-8 -*-
"""flyer_detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12cRmqGfNl5iFFI1IVfde3PIYQtxgxK_t
"""

#Imports
import matplotlib.pyplot as plt
import os
import numpy as np
import cv2
from PIL import Image
from skimage import filters
import pandas as pd
from skimage import draw
from scipy import optimize
import copy
import shutil
import imageio


class flyer_characteristics():
  '''
  A class to store the variables present in the 'radius_from_lslm' function
  Attributes:
    radius -> Radius of the Flyer
    center_row -> Row number of the center of the Flyer
    center_column -> Column number of the center of the Flyer
    image -> Image of Flyer superimposed with the Least-Squares Circle
    leading_row -> The leading row of the Flyer 
    flyer_row -> The row numbers containing the values used for the Least-Squares fit
    flyer_column -> The column numbers containing the values used for the Least-Squares fit
  '''
  def __init__(self):
    self.exit_code=None
    self.radius=None
    self.center_row=None
    self.center_column=None
    self.leading_row=None
    self.flyer_row=None
    self.flyer_column=None
    self.rel_filepath=None
    self.newimg_loc=None
    self.tilt=None

  def show_image(self):
    # It is to be noted that the flyer rows and columns will be the y-coordinates and row-coordinates in a graph.
    plt.imshow(self.image)
    plt.scatter(self.center_column,self.center_row,c='r')
    plt.scatter(self.flyer_column,self.flyer_row,marker='.',s=[5],c='orange')
    plt.show()

class Flyer_Detection():
  '''
  Class which can be used to create a dataframe, for the various radius images.
  '''
  def __init__(self):
    self.df=None

  #Code to filter out ones where the values are null
  def check_blank_image(self,img):
    #Finding the non-zero element locations of the image
    x,y=np.nonzero(img)
    if x.size>0 and y.size>0:
      return False
    else:
      return True

  #Code to check if last row has a value
  def check_last_row(self,img):
    '''
    Inputs: 
    img: An array which is essentially the image
    Outputs:
    True: If the flyer is touching the bottom most part of the image
    False: If the flyer is not touching the bottom most part of the image
    '''
    return np.any(img[img.shape[0]-1])

  #Code to Find Radius
  def radius_from_lslm(self,img,im_loc,output_dir,min_radius=50,max_radius=500,save_output_file=True):
    fc=flyer_characteristics()
    fc.rel_filepath=im_loc
    try:
      if self.check_blank_image(img):
        fc.exit_code=1
        return fc
      #Find the points where the threshold has identified the flyer points
      x,y=np.where(img==255)
      max_x=max(x)
      #I'm creating a dataframe here so that have I can find the lowest column, and isolating those points alone
      df=pd.DataFrame(zip(y,x),columns=['y','x'])
      df=df[df['x']>=max_x-30]
      df=df.sort_values(by=['y','x']).reset_index(drop=True)
      df=df.groupby('y').max().reset_index()
      #I then find the lowest x point, and get 60% of the flyer
      df=df.sort_values(by=['x']).reset_index(drop=True)
      x=np.array(df['x'])
      y=np.array(df['y'])
      max_y=np.amax(y)
      min_y=np.amin(y)
      t=int(np.ceil((max_y-min_y)*0.3))
      t1=y[-1]-t
      t2=y[-1]+t
      #Here, I am making sure to check corner points, and ensure that if +/- 0.3 is more on one side, the difference is transferred to the other side instead
      if t1<min_y:
        if (t1-min_y+t2)<=max_y:
          t2+=(t1-min_y) 
        else: 
          t2=max_y
      if t2>max_y:
        if (t1-(t2-max_y))>=min_y:
          t1-=(t2-max_y) 
        else: 
          t2=min_y
      #Finding the slope of the 
      #I'm reconstucting the flyer image here, for better understandability. This will not affect the radius of curvature but will help in drawing the disk!
      img2=np.zeros((img.shape[0],img.shape[1]))
      img2[x,y]=255
      d=img2[:,t1:t2]
      a1=np.zeros((img.shape[0],t1))
      a2=np.zeros((img.shape[0],img.shape[1]-t2))
      temp=np.concatenate((a1,d,a2),axis=1)
      x,y=np.nonzero(temp)
      fc.flyer_row=x
      fc.flyer_column=y
      df=pd.DataFrame(zip(y,x),columns=['y','x'])
      df=df.sort_values(by=['y']).reset_index(drop=True)
      if len(x)<1 and len(y)<1 :
        fc.exit_code=2
        return fc
      elif len(x)<1 and len(y)>0 :
        fc.exit_code=3
        return fc
      elif len(y)<1 and len(x)>0 :
        fc.exit_code=4
        return fc
      #Using the Least Squares method with Levenberg-Marquardt Optimization (which is Dampened Least Squares similar to L2 regularization)
      x_m = np.mean(x)
      y_m = np.mean(y)
      u= x - x_m
      v = y - y_m
      method_2 = "leastsq"
      #Coope's method can be implemented here to linearize the equation, but I am unsure if that can be used with L-M which is a non-linear method
      #I have written down the equation in the comments the starting point for Coope's method.
      #Code for the least squares 
      def calc_R(xc, yc):
        #2 Xc X + 2 Yc Y + R² - Xc² - Yc² = X² + Y²
        return np.sqrt((x-xc)**2 + (y-yc)**2)

      def f_2(c):
        Ri = calc_R(*c)
        return Ri - Ri.mean()
      #Using Scipy's Least Squares Optimization method to find the center of the circle
      center_estimate = x_m,y_m
      center_2 = optimize.least_squares(f_2, center_estimate, method='lm')

      xc_2, yc_2 = center_2.x
      #Calculating the radius of the circle
      Ri_2       = calc_R(*center_2.x)
      R_2        = Ri_2.mean()
      if R_2>max_radius or R_2<min_radius:
        fc.exit_code=5
        return fc
      fc.radius=R_2
      fc.center_row=xc_2
      fc.center_column=yc_2
      fc.leading_row=max(x)
      #Finding the tilt using arctan and slope value. For a circle, the slope is: -(x-xc)/(y-yc)
      h,v=df.iloc[int(np.ceil(len(df)/2))]
      if (h-xc_2)==0 :
        fc.exit_code=6
        return fc
      fc.tilt=np.arctan((v-yc_2)/(h-xc_2))
      rr, cc = draw.disk((xc_2, yc_2), R_2,
                        shape=temp.shape)
      image=copy.deepcopy(img2) 
      image[rr, cc] = 100
      x,y=np.nonzero(temp)
      image[x, y] = 256

      # Putting the new images into a file
      if save_output_file :
        fc.newimg_loc=output_dir+'/'+im_loc[im_loc.rfind('/')+1:]
        image=(image-np.min(image))/(np.max(image)-np.min(image))
        image = 255 * image # Now scale by 255
        image= image.astype(np.uint8)
        imageio.imwrite(fc.newimg_loc,image)
    except:
      fc.exit_code=7
      return fc
    fc.exit_code=0
    return fc
  #Code to get the final filtered Image
  def filter_image(self,img):
    #Converting the Image to Grayscale
    inputImageGray = cv2.GaussianBlur(img, (7, 7), 0)
    #Applying Sobel Edge Detection on the Image
    edge_sobel = filters.sobel(inputImageGray)
    #Rescaling the Image
    temp=(edge_sobel*255).astype(np.uint8)
    #Thresholding the Image using Binary and Otsu Thresholding
    ret, thresh1 = cv2.threshold(temp, 150, 255,cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    #Erosion and Dilation Element
    element = np.ones((4, 4), np.uint8)
    #Eroding the Element to remove Noise
    mask = cv2.erode(thresh1, element, iterations = 1)
    #Dilation to regain Original Sizings
    mask = cv2.dilate(mask, element, iterations = 1) 
    #Here, I am only finding the connected components
    nlabels, labels, stats, centroids = cv2.connectedComponentsWithStats(mask, None, None, None, 8, cv2.CV_32S)
    areas = stats[1:,cv2.CC_STAT_AREA]
    result = np.zeros((labels.shape), np.uint8)
    #Choosing the Size of the connected components to keep
    for i in range(0, nlabels - 1):
      if areas[i] >= 200: #SIze (this can be changed but currently, this is what worked for me)
        result[labels == i + 1] = 255
    #Cropping off the bottom date
    bottom=int(17*np.floor(result.shape[0]/18))
    result=result[:bottom]
    return result

  #Function to Integrate it all Together
  def create_df_from_input_location(self,input_location,output_location):
    data=[]
    output_dir=os.path.join(output_location,input_location[input_location.rfind('/')+1:])
    if os.path.exists(output_dir):
      shutil.rmtree(output_dir)
    os.makedirs(output_dir)
    for i in sorted(os.listdir(input_location)):
      basewidth = 256
      im_loc=os.path.join(input_location,i)
      if not im_loc.endswith('.bmp'):
        continue
      img = Image.open(im_loc)
      img = np.array(img)
      filtered_image=self.filter_image(img) 
      data.append(vars(self.radius_from_lslm(filtered_image,im_loc,output_dir)))
      if self.check_last_row(filtered_image):
        break
    self.df=pd.DataFrame(data)
    if len(os.listdir(output_dir)) == 0:
      os.remove(output_dir)

  def create_csv_from_df(self,output_location):
    self.df.to_csv(output_location)